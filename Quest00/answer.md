- ### 형상관리 시스템은 왜 나오게 되었을까요?
  - ✅ 파일 관리를 수월하게 하기 위함이다.
    (시간에 따라 파일의 변경사항을 추적하고 기록함으로써, 버전 관리 시스템은 이전 버전으로 복구하거나 조회할 수 있는 기능을 제공합니다. 버전관리는 프로젝트의 모든 수정이 있을때마다 snapshot을 찍습니다. 따라서 필요한 것을 복구하거나 비교할 때 다양한 버전들을 확인할 수 있습니다.)
- ### git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?
  - ✅ git은 분산형 형상관리 시스템으로 여러 곳에서 서버를 두고 소스를 관리한다. 리모트 서버와 별개로 로컬에 서버를 그대로 복제한다(히스토리 포함).
    만약 리모트 서버에 문제가 발생하면 로컬 작업물로 대체할 수 있다. 소스 비교(diff)시에도 서버에 있는 소스가 아닌 로컬에 있는 소스와 수정된 내용의 차이를 보여준다.
  * ### git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?
    - ✅ 리눅스 커널 개발자들이 사용하던 형상관리 시스템인 bitkeeper의 사용이 어려워져 리눅스 토발스가 git이라는 형상관리 시스템을 개발하였다.
- ### git과 GitHub은 어떻게 다를까요?
  - ✅ git은 버전관리 **프로그램**이다. 로컬에 설치하여 사용하는 것이다. GitHub은 **클라우드 서비스**로써 인터넷을 이용해 저장소를 다른 사람과 실시간으로 공유하고 협업할 수 있게 한다.
- ### git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?

  - ✅ **clone** : 원격 저장소에 올라가있는 레포지토리를 로컬로 내려받을 때 사용하는 명령어이다.

    ```
    git clone [원격 저장소 주소]
    ```

  - ✅ **add** : git 저장소에 올리기 전(커밋 전) 스테이징을 한다. 다음 변경을 기록할 때까지 모아두기위해 사용한다.
    ```
    git add [스테이징할 파일명 또는 '.'(수정 파일 전체)]
    ```
  - ✅ **commit** : 로컬 저장소에 변경 내용을 반영한다. add 명령어로 스테이징 상태인 파일만 커밋된다.

    ```
    git commit -m [메세지]

    //스테이징과 커밋을 한번에 수행
    git commit -a -m [메세지]
    ```

  - ✅ **push** : 원격 저장소에 변경 내용을 반영한다.
    ```
    git push [원격 저장소명] [원격 브런치명]
    ```
  - ✅ **pull** : 원격 저장소에서 최신 소스를 가져온 후 병합한다.
    ```
    git pull
    ```
  - ✅ **branch** : 새로운 브런치를 생성한다.

    ```
    git branch [새로운 브런치명]
    ```

  - ✅ **stash** : 변경 내용을 임시저장해두고 필요할 때 불러와서 사용한다. 임시 저장 공간은 스택구조로 되어있다. `git stash`으로 임시저장 후 `git stash pop`으로 불러온다.

- ### git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?
- ### 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?

## 🧗‍♀️ Advanced

- **merge** : 브런치를 병합한다. B 브런치의 내용을 A 브런치에 옮기려면 A 브런치에서 merge 명령어를 수행한다. 명령어를 수행하는 시점의 내용을 기준으로 병합할 뿐 명령 이후의 변경 사항은 각 브런치에만 존재한다.

  ```
  git merge [병합할 브런치]
  ```

- **fetch** : 원격 저장소에서 로컬 저장소로 변경 내용을 가져온다. `git pull` 명령어처럼 원격 저장소의 최신 소스를 가져오지만 병합하지는 않는다. (pull = fetch + merge)
- **reset** : 커밋을 삭제한다.

  ```
  //👇 커밋 자체만을 삭제한다. 작업중인 워킹트리의 수정 사항은 그대로이다.
  git reset [커밋ID]

  //👇 커밋과 그에 해당하는 내용으로 모두 되돌아간다. 커밋 ID 이후의 수정사항이 모두 삭제된다.
  git reset --hard [커밋ID]
  ```

- **revert** : 커밋 자체를 삭제하지 않고 새로운 커밋으로 특정 커밋으로 파일을 복원시킨다.

  ```
  git revert [커밋ID]
  ```

- **checkout** : 브랜치를 이동하거나 특정 커밋으로 이동하여 내용을 확인하고 이전 내용으로 복구한다.
- **switch** : checkout의 역할 중 브런치를 이동하는 것과 동일한 역할을 수행한다.
  ```
  //👇 브런치 생성 후 해당 브런치로 이동한다.
  git checkout -b [새로운 브런치명]
  git switch -c [새로운 브런치명]
  ```
- **restore** : checkout의 역할 중 파일의 수정사항을 되돌리는 것과 동일한 역할을 수행한다.
  파일의 수정 사항을 되돌리는 명령어이다.

  ```
  //👇 HEAD가 참조하는 파일명에 해당하는 파일의 내용으로 되돌린다. 워킹트리에 존재하는 수정사항을 로컬 저장소의 내용으로 되돌린다.
  git checkout HEAD [파일명]
  git restore [파일명]

  //👇 HEAD의 특정 커밋 또는 1단계 전 커밋의 내용으로 HEAD가 이동한다.
  git checkout [커밋ID]
  git checkout HEAD~1

  //👇 해당 커밋의 파일 내용으로 복구한다. HEAD가 이동하는 것이 아니라 파일 내용만 복원한다.
  git restore --source [HEAD~1 또는 커밋ID] [파일명]

  //👇 스테이징된 파일을 되돌린다. (git add 취소)
  git restore --staged [파일명]
  ```
